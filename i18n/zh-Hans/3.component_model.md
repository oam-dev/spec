# 组件模型（The Component Model）


<!--
This section defines the component model.

Components describe functional units that may be instantiated as part of a larger distributed application. For example, each microservice in an application is described as a component. The description itself is not an instance of that microservice, but a declaration of the operational capabilities of that microservice. [Section 6, Application Configuration](6.application_configuration.md) describes how components are grouped together and how instances of those components are then configured.
-->
本节定义了组件模型。

组件描述了可以作为大型分布式应用程序的一部分进行实例化的功能单元。例如，应用程序中的每个微服务都被描述为一个组件。描述本身不是该微服务的实例，而是该微服务的操作能力的声明。[第 6 节，应用程序配置]（6.application_configuration.md）描述了如何将组件分组在一起以及如何配置这些组件的实例。


<!--
## Component Schematics

The role of a component schematic is to permit developers to declare, in infrastructure-neutral format, the operational characteristics of a discrete unit of execution.

For example, a single microservice may be modeled as a component.
-->

## 组件

组件的作用是允许开发人员以与基础结构无关的格式声明分散的执行单元的操作特征。

例如，单个微服务可以以组件进行建模。

<!--
## Units for Time, CPU, Memory, and Disk

In places in this specification, certain units of measure are applied. This section describes those units of measure.
-->

## 时间，CPU，内存和磁盘的单位

在本规范的某些地方，采用了某些度量单位。本节介绍了这些度量单位。

<!--
### Timing (Intervals)

For timing, the default unit of time is seconds, represented as an integer.

### CPU count

CPU count is represented as a floating point number, where `1` means one CPU, `2` means 2 CPUs, and `0.5` means half of a CPU.
-->
### 时间（间隔）

对于计时，默认的时间单位是秒，以整数表示。

### CPU 数量

CPU 计数用浮点数表示，其中 `1` 表示 1 个 CPU，`2` 表示 2 个 CPU，而 `0.5` 表示半个 CPU。


<!--
The exact meaning of this unit varies from platform to platform.  Implementors should consider that logical cpu is equivalent to one AWS vCPU or one Azure vCore or one GCP Core or one IBM vCPU. Fractional values are allowed. If a runtime does not support fractional units, it MUST round up (ceiling function) to the next integer value.
-->

该单元的确切含义因平台而异。实现者应考虑逻辑 CPU 等同于一个 AWS vCPU 或一个 Azure vCore 或一个 GCP Core 或一个 IBM vCPU。允许使用小数值。如果运行时不支持小数单位，则它必须四舍五入（ceiling 函数）到下一个整数值。

<!--
### Memory and Disk

Memory and disk space use the notation for bytes/kilo/mega/giga/tera/peta by just using the major unit:

- `1024` is 1024 bytes
- `88K` is 88 kilobytes
- `5M` is 5 megabytes
- `7G` is 7 gigabytes
- `100T` is 100 terabytes
- `9999P` is 9999 petabytes

If a `B` is appended after the unit letter, it MUST be ignored. Thus, `5M` and `5MB` are treated as identical. Case is unimportant. `15k` and `15K` MUST be treated as the same value.
-->
### 内存和磁盘

内存和磁盘空间仅通过使用主要单位就可以使用字节/千/兆/兆/千兆/兆/千万字节的表示法：

- `1024` 是 1024 字节
- `88K` 是 88 K 字节
- `5M` 是 5 M 字节
- `7G` 是 7 G 字节
- `100T` 是 100 T 字节
- `9999P` 是 9999 P 字节


<!--
## Representation

All component schematics are canonically represented as JSON and can be validated using the provided JSON Schema. Because it is more amenable for human consumption, YAML is also supported, and most of the examples are given in YAML. For the sake of validation, YAML may be converted to an equivalent JSON representation before validating it against the JSON Schema.
-->

## 表示

所有组件均以 JSON 规范表示，并可以使用提供的 JSON Schema 进行验证。因为它更适合人类，YAML 格式也是支持的，并且大多数示例在 YAML 中给出。为了进行验证，可以在根据 JSON 模式验证 YAML 之前将 YAML 转换为等效的 JSON 表示形式。


<!--
### Top-Level Attributes

The following attributes are common across all schemata defined in this document. This structure is designed to allow object type to be determined by scanning two fields (`apiVersion` and `kind`), and provide access to common fields in the `metadata` section. The `spec` section is where type-specific information is located, and in this section the `spec` section defines a `Component`.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `apiVersion` | `string` | Y || The specific version of the OAM specification in use. This version of the specification covers apiVersions in `core.oam.dev/v1alpha1`. |
| `kind` | `string` | Y || For a component schematic, must be `ComponentSchematic`. |
| `metadata` | [`Metadata`](2.overview_and_terminology.md#metadata) | Y | | Component metadata. |
| `spec`| [`Spec`](#spec) | Y || A container for all remaining attributes. |
-->
### 顶级属性

以下属性在本文档中定义的所有架构中都是通用的。该结构旨在允许通过扫描两个字段（`apiVersion` 和 `kind`）来确定对象类型，并提供对 `metadata` 部分中公共字段的访问。`spec` 部分是类型特定信息所在的位置，在 `spec` 部分中，`spec` 部分定义了 `Component`。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `apiVersion` | `string` | Y || 使用的 OAM 规范的特定版本。该规范版本涵盖了在 `core.oam.dev/v1alpha1` 中的 api 版本 |
| `kind` | `string` | Y || 对于组件，必须为 `ComponentSchematic` |
| `metadata` | [`Metadata`](2.overview_and_terminology.md#metadata) | Y | | 组件元数据 |
| `spec`| [`Spec`](#spec) | Y || 所有剩余属性的容器 |


<!--
### Spec

The spec defines the constituent parts of a component.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `parameters` | [`[]Parameter`](#parameter) | N | | The component's configuration options. |
| `workloadType` | `string` | Y | | A succinct, semantically meaningful descriptor of the component's runtime profile. See ["Workload Types"](#workload-types). |
| `osType` | `string` | N |  | The OS required to host (all of) the component's containers (since containers share a kernel with the underlying host). Possible values include:<ul><li>linux</li><li>windows</li></ul> For extended runtimes, this is passed in unaltered. Default can be none and let the runtime decide where to place the component. |
| `arch` | `string` | N |  | The CPU architecture required to host (all of) the component's containers (since containers share physical hardware with the underlying host). Possible values include:<ul><li>i386</li><li>amd64</li><li>arm</li><li>arm64</li></ul> Default can be none and let the runtime chose architecture. |
| `containers` | [`[]Container`](#container) | N | | The OCI container(s) that implement the component. |
| `workloadSettings` | [`[]WorkloadSetting`](#workloadsetting) | N | | Declaration of non-container settings that should be passed to the workload runtime|

All core workload types require `containers` and MUST return an error and cease processing if the `containers` section is empty. However, extended workload types may not require containers. Thus this field is marked optional.
-->

### Spec

Spec 定义了组件的组成部分。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `parameters` | [`[]Parameter`](#parameter) | N | | 组件的配置选项。 |
| `workloadType` | `string` | Y | | 组件运行时配置文件的简洁，语义上有意义的描述符。请参见[“工作负载类型”]（＃workload-types） |
| `osType` | `string` | N |  | 托管（所有）组件容器所需的操作系统（因为容器与基础主机共享内核）。可能的值包括：<ul> <li> linux </li> <li> windows </li> </ul>对于扩展的运行时，将按原样传递。默认值可以为无，让运行时决定组件的放置位置 |
| `arch` | `string` | N |  | 承载（所有）组件容器所需的 CPU 体系结构（因为容器与基础主机共享物理硬件）。可能的值包括：<ul> <li> i386 </li> <li> amd64 </li> <li> arm </li> <li> arm64 </li> </ul>默认值可以为 none，并让运行时选择了体系结构。 |
| `containers` | [`[]Container`](#container) | N | | 实现组件的 OCI 容器。 |
| `workloadSettings` | [`[]WorkloadSetting`](#workloadsetting) | N | | 声明应传递给工作负载运行时的非容器设置|

所有核心工作负载类型都需要 `containers`，并且如果 `containers` 部分为空，则必须返回错误并停止处理。但是，扩展的工作负载类型可能不需要容器。因此，此字段标记为可选。

<!--
### Parameter

The Parameters section defines all of the configurable parameters for this component.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y | | The parameter's name. Must be unique per component. |
| `description` | `string` | N | | A description of the parameter. |
| `type` | `string` | Y | | The parameter's type. One of `boolean`, `number`, `string`, or `null` as defined in [the JSON specification](https://tools.ietf.org/html/rfc7159) and the [JSON Schema Validation spec](https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6) |
| `required` | `boolean` | N |`false` | Whether a value _must_ be provided for the parameter. |
| `default` | type indicated by `type` field | N | | The parameter's default value. |

Parameter `name` fields must be Unicode letter and number characters.
-->
### 参数

`参数` 部分定义了此组件的所有可配置参数。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y | | 参数的名称。每个组件必须唯一。 |
| `description` | `string` | N | | 参数描述。 |
| `type` | `string` | Y | | 参数的类型。 [JSON规范]（https://tools.ietf.org/html/rfc7159）和[JSON Schema Validation spec]（[JSON模式验证规范]）中定义的布尔值，数字，字符串或空值之一 https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6） |
| `required` | `boolean` | N |`false` | 参数是否为必须值 |
| `default` | type indicated by `type` field | N | | 参数的默认值。 |

参数 `name` 字段必须为 Unicode 字母和数字字符。



<!--
### Workload Types

A _workload type_ is an indicator to the runtime as to how it should execute the given workload. In other words, it provides a single field by which the developer can indicate to the runtime how the developer intends for this component to be executed.

Workloads are named using a simple convention: `GROUP/VERSION.KIND`, where `GROUP` is a uniquely named service collection, `VERSION` is an API version, and `KIND` is a group-unique name of a service.

Examples:

- `core.oam.dev/v1alpha1.Singleton`: The group is `core.oam.dev`, meaning it is built-in. The version indicates that this is still an alpha version (`v1alpha1`). The kind is `Singleton`. This means the core singleton runtime must be used for this component.
- `azure.com/v1.Function`: The group is `azure.com` (which is a vendor-specific implementation, and may not be present on all runtimes). The version is `v1`, which marks this as stable. The kind is `Function`, whose runtime implementation is the Azure Functions offering.
- `streams.oam.dev/v1beta2.Kafka`: The group is `streams.oam.dev`, a hypothetical location where certain vendor-neutral extensions may exist. Version is `v1beta2`, indicating that it is moving toward stability. And the kind is `Kafka`.
- `caching.oam.dev/v2.Redis`: The group is `caching.oam.dev`, version is `v2`, and the kind is `Redis`. This describes an implementation of a Redis cache.

> Group, Version, Kind is a [convention in Kubernetes](https://kubernetes.io/docs/reference/using-api/api-concepts/)

There are two kinds of workload types:

- Core workload types
- Extended workload types

-->

### 工作负载类型

_工作负载类型_ 是运行时的指示器，它指示了应如何执行给定的工作负载。换句话说，它提供了一个字段，开发人员可以通过该字段向运行时指示开发人员打算如何执行此组件。

使用一个简单的约定来命名工作负载：`GROUP/VERSION.KIND`，其中 `GROUP` 是唯一命名的服务集合，`VERSION` 是 API 版本，而 `KIND` 是服务的组唯一名称。

例子：

- `core.oam.dev/v1alpha1.Singleton`: 它的分组(Group)是 `core.oam.dev`，表示它是内置的。该版本指示这仍然是 Alpha 版本（`v1alpha1`）。类型(Kind)是 `Singleton`。这意味着必须将核心单例运行时用于此组件。
- `azure.com/v1.Function`: 它的分组(Group)是 `azure.com`（这是特定于供应商的实现，可能并非在所有运行时中都存在）。版本是 `v1`，将其标记为稳定。类型是 `Function`，其运行时实现是 Azure Functions 产品。
- `streams.oam.dev/v1beta2.Kafka`: 该组是 `streams.oam.dev`，一个可能存在某些与供应商无关的扩展的假设位置。版本是 `v1beta2`，表明它正在走向稳定。类型是  `Kafka` 。

- `caching.oam.dev/v2.Redis`: 该组是 `caching.oam.dev`，版本是 `v2`，类型是 `Redis`。这描述了 Redis 缓存的实现。

> 分组(Group), 版本(Version), 类型(Kind) 是 [Kubernetes 中的惯例](https://kubernetes.io/docs/reference/using-api/api-concepts/)

工作负载类型有两种：

- 核心工作负载类型
- 扩展的工作负载类型

<!--
#### Core Workload Types

The core workload types MUST be in the `core.oam.dev` group.

The core workload types MUST all be supported according to the definitions in this section by any runtime implementation of this specification.

Core workload types are focused on several distinguishing points:

1. Whether they are replicable. For singleton types, no replication or scaling traits may be assigned.
2. Whether they are daemonized. For daemon types, if the workload exits, this is considered a fault, and the system must fix it. For non-daemonized types, exit is considered a success if no error is reported.
3. Whether they have a service endpoint with a stable name for network traffic. Workload types that have a service endpoint need a virtual IP address (VIP) with a DNS name to represent the component as a whole, addressable within their network scope and can be assigned traffic routing traits.

All core workload types are container-based, and assume that an implementation is capable of executing an OCI or Docker image as a container, and are capable of working with OCI registries.

The following core workload types are defined by this specification:

|Name|Type|Service endpoint|Replicable|Daemonized|
|-|-|-|-|-|
|Server|core.oam.dev/v1alpha1.Server|Yes|Yes|Yes
|Singleton Server|core.oam.dev/v1alpha1.SingletonServer|Yes|No|Yes
|Worker|core.oam.dev/v1alpha1.Worker|No|Yes|Yes
|Singleton Worker|core.oam.dev/v1alpha1.SingletonWorker|No|No|Yes
|Task|core.oam.dev/v1alpha1.Task|No|Yes|No
|Singleton Task|core.oam.dev/v1alpha1.SingletonTask|No|No|No
-->
#### 核心工作负载类型

核心工作负载类型必须在 `core.oam.dev` 组中。

本规范的任何运行时实现都必须根据本节中的定义全部支持核心工作负载类型。

核心工作负载类型着重于几个区别点：

1. 它们是否可复制。对于单例(singleton)类型，不能指定复制或缩放特性。
2. 它们是否作为守护进程运行。对于守护程序(daemon)类型，如果工作负载已退出，则认为这是故障，系统必须对其进行修复。对于非守护类型，如果没有错误报告，则退出被视为成功。
3. 他们是否具有网络流量名称稳定的服务端点。具有服务端点的工作负载类型需要带有 DNS 名称的虚拟 IP 地址（VIP），以表示整个组件，该组件可以在其网络范围内寻址，并且可以被分配流量路由特征。

所有核心工作负载类型都是基于容器的，并且假定实现能够将 OCI 或 Docker 镜像作为容器执行，并且能够与 OCI 注册中心配合使用。

本规范定义了以下核心工作负载类型：

|Name|Type|Service endpoint|Replicable|Daemonized|
|-|-|-|-|-|
|Server|core.oam.dev/v1alpha1.Server|Yes|Yes|Yes
|Singleton Server|core.oam.dev/v1alpha1.SingletonServer|Yes|No|Yes
|Worker|core.oam.dev/v1alpha1.Worker|No|Yes|Yes
|Singleton Worker|core.oam.dev/v1alpha1.SingletonWorker|No|No|Yes
|Task|core.oam.dev/v1alpha1.Task|No|Yes|No
|Singleton Task|core.oam.dev/v1alpha1.SingletonTask|No|No|No


<!--
##### Server 
Workload type name: `core.oam.dev/v1alpha1.Server`

A Server is used for long-running, scalable workloads that have a network endpoint with a stable name to receive network traffic for the component as a whole. Common use cases include web applications and services that expose APIs. The Server workload type has the following characteristics:
 - Defines a container runtime where zero or more replicas of the same container may be run simultaneously. 
 - An application operator can increase or decrease the number of component replicas by applying and configuring traits when available. 
 - A Server is daemonized. A runtime MUST attempt to restart replicas that exit regardless of error code.
 - A Server has a network endpoint with an automatically assigned virtual IP address (VIP) and DNS name addressable within the network scope to which the component belongs.

> If a Server does not provide at least one `port` on at least one `container`, implementations SHOULD emit an error.
-->
##### Server

工作负载类型名称: `core.oam.dev/v1alpha1.Server`

Server 用于长期运行的，可伸缩的工作负载，这些工作负载的网络端点名称稳定，可以接收整个组件的网络流量。常见的用例包括公开 API 的 Web 应用程序和服务。Server 工作负载类型具有以下特征：

  - 定义一个容器运行时，其中同一容器的零个或多个副本可以同时运行。
  - 应用程序操作员可以通过应用和配置特征（如果可用）来增加或减少组件副本的数量。
  - Server 是守护进程化的。无论错误代码如何，运行时务必尝试重新启动退出的副本。
  - Server 具有网络端点，该端点具有在组件所属网络范围内可自动分配的虚拟IP地址（VIP）和DNS名称。

>如果 Server 未在至少一个 `容器` 上提供至少一个 `端口`，则实现应发出错误。

<!--
##### Singleton Server
Workload type name: `core.oam.dev/v1alpha1.SingletonServer`

A Singleton Server is a special case of the Server workload type that is limited to at most one replica. The Singleton Server workload type as the following characteristics:
 - Defines a container runtime where at most one replica of the same container may be run at a time.  
 - A Singleton Server is daemonized. A runtime MUST attempt to restart the singleton replica if it exits regardless of error code.
 - A Singleton Server has a network endpoint with an automatically assigned virtual IP address (VIP) and DNS name addressable within the network scope to which the component belongs.

> If a Singleton Server does not provide at least one `port` on at least one `container`, implementations SHOULD emit an error.
-->
##### SingletonServer

工作负载类型名称：`core.oam.dev / v1alpha1.SingletonServer`

SingletonServer 是 Server 工作负载类型的一种特例，仅限于最多一个副本。SingletonServer 工作负载类型具有以下特征：

  - 定义一个容器运行时，一次最多可以运行同一容器的一个副本。
  - SingletonServer 是守护进程化的。如果运行时退出，无论错误代码如何，都必须尝试重新启动单例副本。
  - SingletonServer 具有一个网络端点，该端点具有在组件所属的网络范围内可自动分配的虚拟 IP 地址（VIP）和DNS名称。

>如果 SingletonServer 未在至少一个 `容器` 上提供至少一个 `端口`，则实现应发出错误。

<!--
##### Worker
Workload type name: `core.oam.dev/v1alpha1.Worker`

A worker is used for long-running, scalable workloads that do not have a service endpoint for network requests, aside from optional liveliness and readiness probe endpoints on individual replicas. Workers are typically used to pull from queues or provide other offline processing. The worker workload type has the following characteristics:
 - Defines a container runtime where zero or more replicas of the same container may be run simultaneously. 
 - An application operator can increase or decrease the number of worker replicas by applying and configuring traits when available.
 - A worker is daemonized. A runtime MUST attempt to restart replicas that exit regardless of error code.

> If a Worker declares a `port` on any `container`, this SHOULD result in a validation error.
-->
##### Worker

工作负载类型名称：core.oam.dev/v1alpha1.Worker`

除了单个副本上的可选实时性和就绪性探针端点之外，Worker 用于没有网络请求服务端点的长期可扩展工作负载。Worker 通常用于从队列中拉出或提供其他脱机处理。工作负载类型具有以下特征：

  - 定义一个容器运行时，其中同一容器的零个或多个副本可以同时运行。
  - 应用程序操作员可以通过应用和配置特征（如果可用）来增加或减少工作副本的数量。
  - Worker 是守护进程化的。无论错误代码如何，运行时务必尝试重新启动退出的副本。

>如果 Worker 在任何 `容器` 上声明了 `端口`，则应该导致验证错误。


<!--
##### Singleton Worker
Workload type name: `core.oam.dev/v1alpha1.SingletonWorker`

A singleton worker is a special case of the worker workload type that is limited to at most one replica. The singleton worker workload type as the following characteristics:
 - Defines a container runtime where at most one replica of the same container may be run at a time.  
 - A singleton worker is daemonized. A runtime MUST attempt to restart the singleton replica if it exits regardless of error code.

> If a Singleton Worker declares a `port` on any `container`, this SHOULD result in a validation error.
-->
##### Singleton Worker

工作负载类型名称：`core.oam.dev/v1alpha1.SingletonWorker`

Singleton Worker 是工作程序 Worker 负载类型的一种特殊情况，最多只能有一个副本。Singleton Worker 的工作负载类型具有以下特征：

  - 定义一个容器运行时，一次最多可以运行同一容器的一个副本。
  - Singleton Worker 是守护进程化的。如果运行时退出，无论错误代码如何，都必须尝试重新启动单例副本。

>如果 Singleton Worker 在任何 `容器` 上声明了 `端口`，则应该导致验证错误。

<!--
##### Task
Workload type name: `core.oam.dev/v1alpha1.Task`

A task is used to run code or a script to completion. Commonly used to run cron jobs or one-time highly parallelizable tasks that exit and free up resources upon completion. The task workload type has the following characteristics:
 - Defines a container runtime where zero or more replicas of the same container may be run simultaneously.
 - An application operator can increase or decrease the number of worker replicas by applying and configuring traits when available
  - A task is non-daemonized. A runtime MUST NOT attempt to restart replicas that exit without an error code.
-->
##### Task

工作负载类型名称：`core.oam.dev/v1alpha1.Task`

Task 用于运行代码或脚本以完成操作。通常用于运行定时任务或一次性高度可并行化的任务，这些任务在完成时退出并释放资源。Task 工作负载类型具有以下特征：

  - 定义一个容器运行时，其中同一容器的零个或多个副本可以同时运行。
  - 应用程序操作员可以在可用时通过应用和配置特征来增加或减少工作副本的数量
  - Task 是非守护进程化的。运行时务必不要尝试重启没有错误代码而退出的副本。

<!--
##### Singleton Task
Workload type name: `core.oam.dev/v1alpha1.SingletonTask`

A singleton task is a special case of the task workload type that is limited to at most one replica. The singleton task workload type as the following characteristics:
 - Defines a container runtime where at most one replica of the same container may be run at a time.  
  - A singleton task is non-daemonized. A runtime MUST NOT attempt to restart replicas that exit without an error code.


Core workload descriptions MUST include a `container` section in the component schematic. Implementations of the core workload types MUST NOT require that a `workloadSetting` list be present in the component description (though it may allow that some settings are passed that way only if their default values are sufficient for running a workload).
-->
##### Singleton Task

工作量类型名称：`core.oam.dev/v1alpha1.SingletonTask`

Singleton Task 是任务工作负载类型的一种特例，最多只能有一个副本。Singleton Task 工作负载类型具有以下特征：

  - 定义一个容器运行时，一次最多可以运行同一容器的一个副本。
  - Singleton Task 是未守护进程化的。运行时务必不要尝试重启没有错误代码而退出的副本。


核心工作负载描述必须在组件中包括 `容器` 部分。核心工作负载类型的实现绝不能要求组件描述中包含 workloadSetting` 列表（尽管它可能允许某些设置仅在其默认值足以运行工作负载时才通过该设置）。

<!--
#### Extended Workload Types

Extended workload types are _per runtime_, meaning that each runtime may define its own extended workload types beyond this specification. In the present version of the spec, allowing user-defined extended workload types is _not supported_.

Extended workload types MAY use the `containers` section of the component schematic, or MAY omit it. Extended workload types MAY use or omit the `workloadSettings` list in the component schematic. The purpose of the `workloadSetting` list is to provide authors of extended workload types with a location for specifying the configuration of that types.

If an extended workload type is declared in a [component schematic](3.component_model.md), but is not provided by the current platform, the implementation MUST return an error and discontinue the operation.
-->
#### 扩展工作负载类型

扩展的工作负载类型是_per runtime_，这意味着每个运行时都可以定义超出此规范的自己的扩展的工作负载类型。在当前版本的规范中，不支持用户定义的扩展工作负载类型。

扩展的工作负载类型可以使用组件的 `容器` 部分，也可以省略。扩展的工作负载类型可以使用或省略组件示意图中的 `workloadSettings` 列表。 `workloadSetting` 列表的目的是为扩展工作负载类型的作者提供一个用于指定该类型的配置的位置。

如果在[组件模型]（3.component_model.md）中声明了扩展的工作负载类型，但当前平台未提供该类型，则实现必须返回错误并中止该操作。


<!--
### Container

This section describes the runtime configuration necessary to run a containerized workload for this component.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y | | The container's name. Must be unique per component. |
| `image` | `string` | Y | | A path-like or URI-like representation of the location of an OCI image. Where applicable, this MAY be prefixed with a registry address, SHOULD be suffixed with a tag. |
| `resources` | [`Resources`](#resources) | Y | | Resources required by the container. |
| `cmd` | `[]string`| N | | Entrypoint array. |
| `args` | `[]string`| N | | Arguments to the entrypoint. The container image's CMD is used if this is not provided. |
| `env` | [`[]Env`](#env) | N | | Environment variables for the container. |
| `config` | [`[]ConfigFile`](#configfile) | N | | Locations to write configuration as files accessible within the container |
| `ports` | [`[]Port`](#port) | N | | Ports exposed by the container. |
| `livenessProbe` | [`HealthProbe`](#healthprobe) | N | | Instructions for assessing whether the container is alive. |
| `readinessProbe` | [`HealthProbe`](#healthprobe) | N | | Instructions for assessing whether the container is in a suitable state to serve traffic. |
| `imagePullSecret` | `string` | N | | Key that can be used to retrieve the credentials for pulling this secret. |

The details of the way that a runtime takes `imagePullSecret` and loads credentials is left to the OAM runtime implementation. For example, a Kubernetes implementation may treat this as a key that can be [loaded from a secret](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/).
While it is not required, it is RECOMMENDED that `image` names be suffixed with a digest in [OCI format](https://github.com/opencontainers/image-spec/blob/master/descriptor.md#digests). The digest may be used to compute the integrity of the image. `example/foobar@sha256:72e996751fe42b2a0c1e6355730dc2751ccda50564fec929f76804a6365ef5ef`.

> The name field is required and must be 63 characters or less, beginning and ending with an alphanumeric character ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and alphanumerics between.
-->

### Container

本部分描述运行此组件的容器化工作负载所需的运行时配置。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y | | 容器的名称。 每个组件必须唯一。|
| `image` | `string` | Y | | OCI 镜像地址，类似路径或类似 URI 的表示形式。在适用的情况下，可以在其前面加上一个仓库地址，并应在后面加上标签。 |
| `resources` | [`Resources`](#resources) | Y | | 容器所需要的资源 |
| `cmd` | `[]string`| N | | 入口点列表 |
| `args` | `[]string`| N | | 入口点的参数。如果未提供，则使用容器映像的CMD。 |
| `env` | [`[]Env`](#env) | N | | 容器的环境变量。 |
| `config` | [`[]ConfigFile`](#configfile) | N | | 将配置写入文件的位置可在容器内访问 |
| `ports` | [`[]Port`](#port) | N | | 容器所暴露的端口 |
| `livenessProbe` | [`HealthProbe`](#healthprobe) | N | | 评估容器是否还存活的探测 |
| `readinessProbe` | [`HealthProbe`](#healthprobe) | N | | 评估容器是否可以提供服务 |
| `imagePullSecret` | `string` | N | | 可用于检索用于提取此 secret 的凭据的密钥 |

运行时获取 `imagePullSecret` 并加载凭据的方式的细节留给 OAM 运行时实现。例如，Kubernetes 实现可以将此密钥视为可以[从 secret 中加载]的密钥（https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/）。
虽然不是必需的，但建议在 `镜像` 名称后加上 [OCI格式]（https://github.com/opencontainers/image-spec/blob/master/descriptor.md#digests）的摘要。摘要可以用于计算图像的完整性。`example/foobar@sha256:72e996751fe42b2a0c1e6355730dc2751ccda50564fec929f76804a6365ef5ef`。

>名称字段是必填字段，并且必须为 63 个字符或更少，以字母数字（[a-z0-9A-Z]）开头和结尾，并带有破折号（-），下划线（_），点（.）和字母数字之间

<!--
### WorkloadSetting

This section describes additional configuration for a workload (settings that are not about a container runtime).

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y | | The name of this workload setting |
| `type` | `string` | N | `string` | The data type passed into the value. This is used as a hint to the underlying implementation |
| `value` | any | N || The value for this workload setting, if `fromParam` is not present |
| `fromParam` | string | N || The name of the parameter from whence to fetch the setting value. Overrides `value` |

The `workloadSettings` section of a component schematic is an extensible location for specifying workload-specific configuration. The core workload types do not use this section, as it is reserved for extended workloads. Its primary purpose is to hold definitions for _non-containerized extended workload types_, though it may be used for containerized extended workload types where applicable.

> The name field is required and must be 63 characters or less, beginning and ending with an alphanumeric character ([a-z0-9A-Z]) with dashes (-), underscores (_), dots (.), and alphanumerics between.

The `workloadSettings` section of a component schematic is an extensible location for specifying workload-specific configuration. Its primary purpose is to hold definitions for _non-containerized extended workload types_, though it may be used for containerized workload types where applicable.

> The available settings are listed on the workload type object. See [section 7](7.workload_types.md) for details.

Workload settings are passed as name/value pairs, where the type of value may be anything supported by JSON/YAML. The runtime environment MAY choose to treat `workloadSettings` values as opaque, merely passing them directly to an implementing service. A runtime MAY return an error if certain constraints are not met, including:

- Missing an expected name/value pair
- An unrecognized key/value pair
- A malformed value
- An incompatibility based on the provided name/value pairs

```yaml
apiVersion: core.oam.dev/v1alpha1
kind: ComponentSchematic
metadata:
  name: ext-workload-example
spec:
  workloadType: ext.example.com/v1.ExtTask
  os: linux
  workloadSettings:
  - name: threshold
    type: numeric
    value: 55
  - name: workLabel
    type: string
```

The above illustrates a workload type with a few configurable settings.
-->

### WorkloadSetting

本节介绍工作负载的其他配置（与容器运行时无关的设置）。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y | | WorkloadSetting 的名称 |
| `type` | `string` | N | `string` | 传递给值的数据类型。 这是对底层实现的提示 |
| `value` | any | N || 如果不存在 `fromParam`，则此 WorkloadSetting 的值 |
| `fromParam` | string | N || 从何处获取设置值的参数名称。覆盖 `value` |

组件的 `WorkloadSetting` 部分是用于指定工作负载特定配置的可扩展位置。核心工作负载类型不使用此部分，因为它保留用于扩展的工作负载。它的主要目的是保存 _非容器化_ 扩展工作负载类型的定义，尽管在适用的情况下它也可以用于容器化的扩展工作负载类型。

>名称字段是必填字段，并且必须为 63 个字符或更少，以字母数字（[a-z0-9A-Z]）开头和结尾，并带有破折号（-），下划线（_），点（.）和字母数字之间


>可用设置在 WorkloadSetting 对象上列出。有关详细信息，请参见[第7节]（7.workload_types.md）。

WorkloadSetting 设置作为名称/值对传递，其中值的类型可以是 JSON/YAML 支持的任何值。运行时环境可以选择将 `WorkloadSetting` 值视为不透明，仅将其直接传递给实现服务。如果不满足某些约束，则运行时可能会返回错误，包括：


- 缺少预期的名称/值对
- 无法识别的键/值对
- 格式错误
- 基于提供的名称/值对的不兼容

```yaml
apiVersion: core.oam.dev/v1alpha1
kind: ComponentSchematic
metadata:
  name: ext-workload-example
spec:
  workloadType: ext.example.com/v1.ExtTask
  os: linux
  workloadSettings:
  - name: threshold
    type: numeric
    value: 55
  - name: workLabel
    type: string
```

上面说明了具有一些可配置设置的工作负载类型。


<!--
### Resources

Resources describe compute resources attached to a runtime.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `cpu` | [`CPU`](#cpu) | Y |  | Specifies the attributes of the cpu resource required for the container. |
| `memory` | [`Memory`](#memory) | Y | | Specifies the attributes of the memory resource required for the container. |
| `gpu` | [`GPU`](#gpu) | N |  | Specifies the attributes of the gpu resources required for the container. |
| `volumes` | [`[]Volume`](#volume) | N | | Specifies the attributes of the volumes that the container uses. |
| `extended` | [`[]ExtendedResource`](#extendedresource) | N | | Implementation-specific extended resource requirements |

For any resource that cannot be satisfied by the underlying platform, the platform MUST return an error and cease deployment. A resource is considered a requirement, and failure to meet that requirement means the runtime MUST NOT deploy the application. For example, if an application requests `1P` of memory, and that amount of memory is not available, the application deployment must fail. Likewise, if an application requires `1` gpu, and the runtime does not provide gpus, the application deployment MUST fail.
--->
### Resources

Resources 描述了关联到运行时的计算资源。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `cpu` | [`CPU`](#cpu) | Y |  | 指定容器所需的 cpu 资源的属性。 |
| `memory` | [`Memory`](#memory) | Y | | 指定容器所需的内存资源的属性 |
| `gpu` | [`GPU`](#gpu) | N |  | 指定容器所需的 gpu 资源的属性 |
| `volumes` | [`[]Volume`](#volume) | N | | 指定容器所需的卷的属性|
| `extended` | [`[]ExtendedResource`](#extendedresource) | N | | 特定于实施的扩展资源需求 |

对于基础平台无法满足的任何资源，平台务必返回错误并停止部署。资源被认为是必需的，并且不能满足该要求意味着运行时不得部署应用程序。 例如，如果应用程序请求 `1P` 内存，而该内存量不可用，则应用程序部署必定会失败。同样，如果应用程序需要 `1` GPU，而运行时不提供 GPU，则应用程序部署必须失败。

<!--
#### CPU

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `required` | `double` | Y |  | The minimum number of logical cpus required for running this container. |

See the Units section above for valid values.
-->
#### CPU

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `required` | `double` | Y |  | 运行此容器所需的最小逻辑CPU数。 |

有关有效值，请参见上面的单位部分。

<!--
#### Memory

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `required` | `string` | Y | | The minimum amount of memory in MB required  for running this container. The value should be a positive integer, greater than zero. |

See the Units section above for valid values.
-->
#### 内存

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `required` | `string` | Y | | 运行此容器所需的最小内存量（以MB为单位）。该值应为大于零的正整数。 |

有关有效值，请参见上面的单位部分。

<!--
#### GPU

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `required` | `double` | Y |  | The minimum number of gpus  required for running this container. |

See the Units section above for valid values.
-->
#### GPU

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `required` | `double` | Y |  | 运行此容器所需的最小 gpu 数。 |

有关有效值，请参见上面的单位部分。

<!--
#### Volume

Volume describes name, a location to mount the volume, along with access mode (such as read/write or read-only) and sharing policy for the mount. It also describes the underneath disk attributes needed by the volume.
The format of the path is specific to the operating system of the consuming component, though implementations SHOULD provide support for UNIX-like path representations.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y |  | Specifies the name used to reference the path. |
| `mountPath` | `string` | Y |  | Specifies the actual mount path in the filesystem. |
| `accessMode` | `string` | N | `RW` | Specifies the access mode. Allowed values are `RW` (read/write) and `RO` (read-only). |
| `sharingPolicy` | `string` | N | `Exclusive` | The sharing policy for the mount, indicating if it is expected to be shared or not. Allowed values are `Exclusive` and `Shared`. |
| `disk` | [`Disk`](#disk) | N |  | Specifies the attributes of the underneath disk resources required by the volume. |

See the Units section above for valid values.

Example:

```yaml
name: "configuration"
mountPath: /etc/config
accessMode: RO
sharingPolicy: Shared
disk:
  required: "2G"
  ephemeral: n
```

The above requires that a read-only volume be mounted at the path `/etc/config`, backed by a volume that provides at least 2G of non-ephemeral storage.

-->
#### Volume

Volume 描述名称，安装卷的位置以及访问模式（例如读/写或只读）和安装的共享策略。它还描述了该卷所需的磁盘下属性。
路径的格式特定于使用方组件的操作系统，尽管实现应提供对类似 UNIX 的路径表示的支持。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y |  | 指定用于引用路径的名称 |
| `mountPath` | `string` | Y |  | 指定文件系统中的实际安装路径。 |
| `accessMode` | `string` | N | `RW` | 指定访问模式。允许的值为 `RW`（读/写）和 `RO`（只读）。 |
| `sharingPolicy` | `string` | N | `Exclusive` | 装载的共享策略，指示是否希望共享。 允许的值为 `独占` 和 `共享`。 |
| `disk` | [`Disk`](#disk) | N |  | 指定卷所需的底层磁盘资源的属性。|

有关有效值，请参见上面的单位部分。

例子:

```yaml
name: "configuration"
mountPath: /etc/config
accessMode: RO
sharingPolicy: Shared
disk:
  required: "2G"
  ephemeral: n
```

上述配置要求将只读卷挂载在路径 `/etc/config` 上，背后是一个提供至少 2G 非临时存储的卷。


<!--
#### Disk

The disk specifies the attributes of the disk used by the volume. It describes information such as minimum disk size and the disk is ephemeral or not. Ephemeral disk indicates the component requires minimum disk size on the node to run it. For example, image processing component may require a larger cache on the node to run could use ephemeral disk. When ephemeral disk is set to false, it indicates external disk will be used.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `required` | `string` | Y |  | The minimum disk size required for running this container. The value should be a positive value, greater than zero. |
| `ephemeral` | `boolean` | N | | Specifies whether external disk needs to be mounted or not. |

See the Units section above for valid values.
-->
#### Disk

磁盘指定卷使用的磁盘的属性。它描述了诸如最小磁盘大小以及磁盘是否为临时磁盘之类的信息。临时磁盘表示该组件需要节点上的最小磁盘大小才能运行它。例如，图像处理组件可能需要在临时节点上运行较大的缓存才能使用临时磁盘。当临时磁盘设置为 false 时，表明将使用外部磁盘。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `required` | `string` | Y |  | 运行此容器所需的最小磁盘大小。 该值应为正值，大于零。|
| `ephemeral` | `boolean` | N | | 指定是否需要安装外部磁盘。 |

有关有效值，请参见上面的单位部分。

<!--
#### ExtendedResource

An extended resource is a declaration of a resource requirement for an implementation-specific resource. For example, OAM-compliant platforms may expose special hardware. This field allows containers to indicate that such special offerings are required in order for the containers to operate.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y | | The name of the resource, as a Group/Version/Kind |
| `required` | `string` | Y | | The required condition. |

The `name` field MUST be a group/version/kind identifying the specific resource.

Example:

```yaml
extended:
- name: ext.example.com/v1.MotionSensor
  required: "1"
- name: ext.example.com/v2beta4.ServoModel
  required: z141155-t100
```

If the named extended resource is not available for any reason, implementations MUST return an error when a component instance is created.
-->
#### ExtendedResource

ExtendedResource 是特定于实现的资源的资源要求的声明。例如，符合 OAM 的平台可能会公开特殊的硬件。该字段允许容器指示需要此类特殊提供物才能使容器运行。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y | | 资源的名称以 Group/Version/Kind 的形式|
| `required` | `string` | Y | | The required condition. |

名称字段必须是标识特定资源的组/版本/种类。

例子:

```yaml
extended:
- name: ext.example.com/v1.MotionSensor
  required: "1"
- name: ext.example.com/v2beta4.ServoModel
  required: z141155-t100
```

如果命名的 ExtendedResource 由于任何原因不可用，则创建组件实例时，实现必须返回错误。

<!--
### Env

Env describes an environment variable as a name/value pair of strings.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y || The environment variable name. Must be unique per container. |
| `value` | `string` | N || The environment variable value. If this is not supplied, `fromParam` must be supplied |
| `fromParam` | `string` | N || The parameter whose value should be substituted into this variable as a value |

The `name` field must be composed of valid Unicode letter and number characters, as well as `_` and `-`.

Example:

```yaml
env:
  - name: "ADMIN_USER"
    value: "admin"  # This is a literal value
  - name: "LOGO_URL"
    fromParam: "logoURL" # This will cause the value to be read from the parameter whose name is `logoURL`
```

If both `fromParam` and `value` are specified, `fromParam` MUST take precedence, even if the parameter value is an empty value. If neither is specified, the runtime MUST produce an error.
-->
### 环境

环境将环境变量描述为字符串的名称/值对。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y || 环境变量名称。每个容器必须唯一。 |
| `value` | `string` | N || 环境变量值。如果未提供，则必须提供 `fromParam`。 |
| `fromParam` | `string` | N || 该参数的值应作为值替换到此变量中 |

`name` 字段必须由有效的 Unicode 字母和数字字符以及 `_` 和 `-` 组成。

例子:

```yaml
env:
  - name: "ADMIN_USER"
    value: "admin"  # This is a literal value
  - name: "LOGO_URL"
    fromParam: "logoURL" # This will cause the value to be read from the parameter whose name is `logoURL`
```

如果同时指定了 fromParam 和 value，则即使参数值是一个空值，fromParam 也必须优先。如果两者均未指定，则运行时务必产生错误。

<!--
### ConfigFile

ConfigFile describes a path to a file available within the container, as well as the data that will be written into that file. This provides a way to inject configuration files into a container.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `path` | `string` | Y || An absolute path within the container. |
| `value` | `string` | N || The data to be written into the file at the specified path. If this is not supplied, `fromParam` must be supplied |
| `fromParam` | `string` | N || The parameter whose value should be written into this file as a value |

The `path` field must contain a path that abides by the pathing rules of the underlying operating system. If a relative path is given, implementations MUST assume the path is relative to the root directory of the container. Implementations MAY produce an error if using such a path would violate security measures or path layout requirements.

Example:

```yaml
config:
  - path: "/etc/access/default_user.txt"
    value: "admin"  # This is a literal value
  - path: "/var/run/db-data"
    fromParam: "sourceData" # This will cause the value to be read from the parameter whose name is `sourceData`
```

If both `fromParam` and `value` are specified, `fromParam` MUST take precedence, even if the parameter value is an empty value. If neither is specified, the runtime MUST produce an error.
-->
### 配置文件

配置文件描述了容器中可用文件的路径，以及将写入该文件的数据。这提供了一种将配置文件注入到容器中的方法。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `path` | `string` | Y || 容器内的一个绝对路径。 |
| `value` | `string` | N || 要在指定路径下写入文件的数据。如果未提供，则必须提供 `fromParam`。 |
| `fromParam` | `string` | N || 其值应作为值写入此文件的参数 |

`path` 字段必须包含一个遵守底层操作系统的路径规则的路径。如果给出了相对路径，实现必须假定该路径相对于容器的根目录。如果使用这样的路径会违反安全措施或路径布局要求，则实现可能会产生错误。

例子:

```yaml
config:
  - path: "/etc/access/default_user.txt"
    value: "admin"  # This is a literal value
  - path: "/var/run/db-data"
    fromParam: "sourceData" # This will cause the value to be read from the parameter whose name is `sourceData`
```

如果同时指定了 fromParam 和 value，则即使参数值是一个空值，fromParam 也必须优先。如果两者均未指定，则运行时务必产生错误。

<!--
### Port

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y || A descriptive name for the port. Must be unique per container. |
| `containerPort` | `integer` | Y || The port number. Must be unique per container. |
| `protocol` | `string` | N | `TCP` | Indicates the transport layer protocol used by the server listening on the port. Valid values are `TCP` and `UDP`. |

The `name` field must be lowercase alphabetical characters as present in the ASCII character set (0061-007A).
-->
### 端口

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y || 用于描述端口的名称。每个容器必须唯一。 |
| `containerPort` | `integer` | Y || 端口。每个容器必须唯一。 |
| `protocol` | `string` | N | `TCP` | 表示服务器监听端口所使用的传输层协议。有效值为 `TCP` 和 `UDP`。
 |

`name` 字段必须是 ASCII 字符集（0061-007A）中存在的小写字母字符。

<!--
### HealthProbe

Health Probe describes how a probing operation is to be executed as a way of determining the health of a component.

| Attribute | Type | Required | Default Value | Description |
|-----------|------|----------|---------------|-------------|
| `exec` | [`Exec`](#exec) | N || Instructions for assessing container health by executing a command. Either this attribute or the `httpGet` attribute or the `tcpSocket` attribute MUST be specified. This attribute is mutually exclusive with both the `httpGet` attribute and the `tcpSocket` attribute. |
| `httpGet` | [`HTTPGet`](#httpget) | N || Instructions for assessing container health by executing an HTTP GET request. Either this attribute or the `exec` attribute or the `tcpSocket` attribute MUST be specified. This attribute is mutually exclusive with both the `exec` attribute and the `tcpSocket` attribute. |
| `tcpSocket` | [`TCPSocket`](#tcpsocket) | N || Instructions for assessing container health by probing a TCP socket. Either this attribute or the `exec` attribute or the `httpGet` attribute MUST be specified. This attribute is mutually exclusive with both the `exec` attribute and the `httpGet` attribute. |
| `initialDelaySeconds` | `integer` | N | `0` | Number of seconds after the container is started before the first probe is initiated. |
| `periodSeconds` | `integer` | N | `10` | How often, in seconds, to execute the probe. |
| `timeoutSeconds` | `integer` | N | `1` | Number of seconds after which the probe times out. |
| `successThreshold` | `integer` | N | `1` | Minimum consecutive successes for the probe to be considered successful after having failed. |
| `failureThreshold` | `integer` | N | `3` | Number of consecutive failures required to determine the container is not alive (liveness probe) or not ready (readiness probe). |

See the Units section above for valid time values.
-->
### 健康检查探测

运行状况探测描述了如何执行探测操作，以确定组件的运行状况。

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `exec` | [`Exec`](#exec) | N || 通过执行命令评估容器运行状况的说明。必须指定该属性或 `httpGet` 属性或 `tcpSocket` 属性。该属性与 httpGet 属性和 tcpSocket 属性互斥。 |
| `httpGet` | [`HTTPGet`](#httpget) | N || 通过执行HTTP GET请求评估容器运行状况的说明。 必须指定这个属性或 `exec` 属性或`tcpSocket` 属性。该属性与 `exec` 属性和 `tcpSocket` 属性互斥。 |
| `tcpSocket` | [`TCPSocket`](#tcpsocket) | N || 通过探测 TCP 套接字来评估容器运行状况的说明。必须指定这个属性或 `exec` 属性或`httpGet` 属性。该属性与 `exec` 属性和 `httpGet` 属性互斥。 |
| `initialDelaySeconds` | `integer` | N | `0` | 容器启动后开始第一次探测之前的秒数。 |
| `periodSeconds` | `integer` | N | `10` | 多少秒执行一次探测 |
| `timeoutSeconds` | `integer` | N | `1` | 执行探测的超时时间 |
| `successThreshold` | `integer` | N | `1` | 探针失败的最少连续成功次数将被视为成功。 |
| `failureThreshold` | `integer` | N | `3` | 确定容器未运行（存活探针）或未就绪（就绪探针）所需的连续失败次数。 |

有关有效时间值，请参见上面的单位部分。

### Exec

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `command` | `[]string` | Y || 在容器内部执行以评估其运行状况的命令。该命令的每个以空格分隔的标记都是一个单独的数组元素。退出 `0`的命令被认为是成功的探测，而所有其他退出代码被认为是失败。 |

### HTTPGet

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `path` | `string` | Y || HTTP GET 请求应指向的相对于 `port` 的端点。 |
| `port` | `integer` | Y || HTTP GET 请求应定向到的容器内的 TCP 套接字。 |
| `httpHeaders` | [`[]HTTPHeader`](#httpheader) | N || 可选的HTTP标头 |

### HTTPHeader

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `name` | `string` | Y || HTTP 头名称。每个基于 HTTP GET的探针必须唯一。 |
| `value` | `string` | Y || HTTP 头的值 |

`name` 和 `value` 的有效值都必须遵守 HTTP/1.1规范（https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2）

### TCPSocket

| 属性 | 类型 | 是否必须 | 默认值 | 描述 |
|-----------|------|----------|---------------|-------------|
| `port` | `integer` | Y || 应当探测容器内的 TCP 套接字以评估容器的运行状况。 |

端口必须是大于 0 的整数。

### 例子

本节说明了以上定义的组件的使用。
描述 Twitter 机器人应用程序的两个独立组件。

我们的第一个组件是前端管理界面。最终用户（机器人
管理员）使用基本身份验证进行身份验证。该界面允许最终用户
配置机器人将鸣叫的内容种类以及间隔时间它将这样做。

由于此组件是无状态的，可水平扩展的并且公开了端点，因此最好对它进行描述
作为 `服务`。后端的用户名，密码和地址组件是可配置的。

```yaml
apiVersion: core.oam.dev/v1alpha1
kind: ComponentSchematic
metadata:
  name: frontend
  annotations:
    version: v1.0.0
    description: >
      Sample component schematic that describes the administrative interface for our Twitter bot.
spec:
  workloadType: Server
  osType: linux
  parameters:
  - name: username
    description: Basic auth username for accessing the administrative interface
    type: string
    required: true
  - name: password
    description: Basic auth password for accessing the administrative interface
    type: string
    required: true
  - name: backend-address
    description: Host name or IP of the backend
    type: string
    required: true
  containers:
  - name: my-twitter-bot-frontend
    image:
      name: example/my-twitter-bot-frontend:1.0.0
      digest: sha256:6c3c624b58dbbcd3c0dd82b4c53f04194d1247c6eebdaab7c610cf7d66709b3b
    resources:
      cpu:
        required: 1.0
      memory:
        required: 100MB
    ports:
    - name: http
      value: 8080
    env:
    - name: USERNAME
      fromParam: 'username'
    - name: PASSWORD
      fromParam: 'password'
    - name: BACKEND_ADDRESS
      fromParam: 'backend-address'
    livenessProbe:
      httpGet:
        port: 8080
        path: /healthz
    readinessProbe:
      httpGet:
        port: 8080
        path: /healthz
```

我们的第二个组件同时实现了Twitter机器人的后端
管理界面和将发布的后台工作进程
最终用户定义的内容（以最终用户定义的间隔）
管理界面）。该组件还保留其最终用户定义的
配置到磁盘作为 JSON 文件。

该组件的设计防止其水平缩放，因此我们仅应
最多有一个实例正在运行。它还具有用于管理接口的端点。因此，最好地描述此组件
作为 `SingletonServer`。Twitter API的连接详细信息是
可配置的。组件示意图还描述了文件系统位置组件保留最终用户定义的配置的位置。

```yaml
apiVersion: core.oam.dev/v1alpha1
kind: ComponentSchematic
metadata:
  name: admin-backend
  annotations:
    version: v1.0.0
    description: >
      Sample component schematic that describes the backend for our Twitter bot.
spec:
  workloadType: core.oam.dev/v1.SingletonServer
  osType: linux
  parameters:
  - name: twitter-consumer-key
    description: Twitter API consumer key
    type: string
    required: true
  - name: twitter-consumer-secret
    description: Twitter API consumer secret
    type: string
    required: true
  - name: twitter-access-token
    description: Twitter API access token
    type: string
    required: true
  - name: twitter-access-token-secret
    description: Twitter API access token secret
    type: string
    required: true
  containers:
  - name: my-twitter-bot-backend
    image:
      name: example/my-twitter-bot-backend:1.0.0
      digest: sha256:6c3c624b58dbbcd3c0dd82b4c53f04194d1247c6eebdaab7c610cf7d66709b3b
    resources:
      cpu:
        required: 1.0
      memory:
        required: 100MB
      volumes:
      - name: config
        mountPath: /var/lib/my-twitter-bot/conf
        accessMode: RW
        sharingPolicy: Exclusive
    ports:
    - name: http
      value: 8080
    env:
    - name: TWITTER_CONSUMER_KEY
      fromParam: 'twitter-consumer-key'
    - name: TWITTER_CONSUMER_SECRET
      fromParam: 'twitter-consumer-secret'
    - name: TWITTER_ACCESS_TOKEN
      fromParam: 'twitter-access-token'
    - name: TWITTER_ACCESS_TOKEN_SECRET
      fromParam: 'twitter-access-token-secret'
    livenessProbe:
      httpGet:
        port: 8080
        path: /healthz
    readinessProbe:
      httpGet:
        port: 8080
        path: /healthz
```

<!--
#### Example: Extended Workload Type

Imagine a service runtime that checks out code from a Git repository and executes it as an Azure function. This service might be used as follows:

```yaml
apiVersion: core.oam.dev/v1alpha1
kind: ComponentSchematic
metadata:
  name: azurefunction
  annotations:
    version: v1.0.0
    description: "Extended workflow example"
spec:
  workloadType: azure.com/v1.Function
  parameters:
  - name: github-token
    description: GitHub API session key
    type: string
    required: true
  workloadSettings:
    - name: source
      value: git://git.example.com/function/myfunction.git
    - name: github_token
      fromParam: github-token
```
-->

#### 示例：扩展工作负载类型

想象一下一个服务运行时，该服务运行时从 Git 仓库中签出代码并将其作为 Azure函数执行 可以按以下方式使用此服务：

```yaml
apiVersion: core.oam.dev/v1alpha1
kind: ComponentSchematic
metadata:
  name: azurefunction
  annotations:
    version: v1.0.0
    description: "Extended workflow example"
spec:
  workloadType: azure.com/v1.Function
  parameters:
  - name: github-token
    description: GitHub API session key
    type: string
    required: true
  workloadSettings:
    - name: source
      value: git://git.example.com/function/myfunction.git
    - name: github_token
      fromParam: github-token
```


<!--
| Previous Part        | Next Part           | 
| ------------- |-------------| 
|[2. Overview and Terminology](2.overview_and_terminology.md)    |  [4. Application Scopes](4.application_scopes.md)| 
-->
| 上一部分        | 下一部分           | 
| ------------- |-------------| 
|[2. 概览和术语](2.overview_and_terminology.md)    |  [4. 应用边界](4.application_scopes.md)| 
